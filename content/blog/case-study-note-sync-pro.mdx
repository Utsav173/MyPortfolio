---
title: 'Case Study: Building Note Sync Pro with Next.js, Convex, and Gemini AI'
description: 'A deep dive into the architecture of Note Sync Pro, a modern blog platform featuring a full-stack TypeScript environment, real-time database with Convex, and an AI writing assistant powered by Google Gemini.'
published: true
date: '2025-09-16'
tags: ['Next.js', 'Convex', 'Gemini AI', 'Case Study', 'Full-Stack', 'TypeScript']
---

## The Vision: A Modern, AI-Powered Blogging Experience

For my "Note Sync Pro" project, I wanted to build more than just a standard blog. The goal was to create a seamless, modern writing platform that leverages the best of a full-stack TypeScript environment, a real-time database, and the creative power of generative AI.

The core vision was to build a platform where writers could not only manage their content effortlessly but also get assistance from an AI to enhance their creative process, from generating ideas to refining their tone.

---

## Core Technologies

- **Framework:** Next.js (App Router)
- **Database & Backend:** Convex (Real-time serverless backend)
- **AI Integration:** Google Gemini via the Vercel AI SDK
- **Text Editor:** Plate.js (A rich text editor framework for React)
- **Image Uploads:** UploadThing
- **Authentication:** Custom JWT-based system
- **Styling:** Tailwind CSS with shadcn/ui

---

## Key Challenge: Seamless AI & Real-Time Data Integration

The primary challenge was to tightly integrate the AI writing assistant directly into the rich text editor while ensuring the entire application state remained synchronized in real-time. A user should be able to trigger an AI action, see the generated content stream directly into the editor, and have it save instantly without a manual "save" button.

### My Solution: A Reactive, Serverless Architecture

#### 1. Convex for the Real-Time Backend

Convex was the perfect choice for this. It is a serverless platform that provides a real-time database out of the box. Instead of building a traditional REST or GraphQL API, I wrote my backend functions (called "mutations" and "queries") directly in TypeScript, and Convex handled the rest.

When a user types in the Plate.js editor, a Convex `mutation` is called to update the document. Convex then automatically pushes the updated state to all connected clients, ensuring perfect synchronization.

```typescript
// A simplified Convex mutation for updating a post
import { mutation } from './_generated/server';
import { v } from 'convex/values';

export const updateContent = mutation({
  args: {
    postId: v.id('posts'),
    content: v.string(),
  },
  handler: async (ctx, args) => {
    // Authentication check would go here
    await ctx.db.patch(args.postId, { content: args.content });
  },
});
```

#### 2. Vercel AI SDK for Streaming AI Responses

To make the AI feel truly integrated, I used the Vercel AI SDK. When a user prompts the AI assistant, a server-side Next.js API route is called. This route communicates with the Google Gemini API and streams the response back to the client.

The `useCompletion` hook from the SDK makes it incredibly easy to handle this stream on the frontend and update the editor in real-time as the AI "thinks."

```tsx
// Simplified example of the AI trigger in the React component
'use client';
import { useCompletion } from 'ai/react';

function AiWritingAssistant({ editor }) {
  const { completion, complete } = useCompletion({
    api: '/api/generate', // Next.js API route
  });

  const handleGenerate = () => {
    const prompt = 'Summarize the following text: ...';
    complete(prompt);
  };

  // This effect would stream the 'completion' text into the editor
  // ...

  return <button onClick={handleGenerate}>Generate Summary</button>;
}
```

---

## What I Learned

- **The Power of a True Full-Stack Framework:** Convex allowed me to stay in a TypeScript-only environment for both frontend and backend logic, dramatically increasing development speed.
- **Streaming is Key for AI UX:** For generative AI features, streaming the response token-by-token is non-negotiable. It provides instant feedback and makes the application feel alive and responsive.
- **Component-Based Editors are the Future:** Using a framework like Plate.js, which is built on top of Slate.js, gives you granular control over the editor's behavior, making complex integrations like this possible.

Note Sync Pro was a challenging but incredibly rewarding project. It pushed my skills in building complex, interactive, and intelligent web applications and demonstrated the immense potential of combining modern serverless backends with generative AI.
